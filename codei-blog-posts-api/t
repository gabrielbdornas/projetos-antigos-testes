=> [32m#<Post:0x00007ff8c49c99f0[0m
 id: [1;34m4[0m,
 name: [31m[1;31m"[0m[31mDeixe seu codigo ruby mais estiloso[1;31m"[0m[31m[0m,
 resume: [31m[1;31m"[0m[31m[1;31m"[0m[31m[0m,
 content:
  [31m[1;31m"[0m[31mÃ‰ uma pena mas algumas pessoas nÃ£o pensam em estÃ©tica quando estÃ£o codando. Certamente o uso adequado de espaÃ§os e recuo sÃ£o comuns mas podemos ir mais fundo que isso. Ã‰ certo que um bom cÃ³digo deve antes de tudo ser executado de maneira eficiente. Mas quero ir alÃ©m. Penso que ele tambÃ©m deve ser legÃ­vel para quem os criam depuram e mantÃªm. Tudo estÃ¡ funcionando e certamente isso Ã© importante mas como quem gosta de organizaÃ§Ã£o e uniformidade acredito que codar nÃ£o se trata somente de seguir boas prÃ¡ticas de implementaÃ§Ã£o. Ã‰ preciso estilo sabor e porque nÃ£o consistÃªncia.Sei que outros jÃ¡ escreveram uma tonelada de artigos sobre esse tÃ³pico. Esta Ã© apenas uma pequena tentativa de expressar como gosto de organizar visualmente meu cÃ³digo. Neste sentido Ruby Ã© Ã³timo pois nos permite grande flexibilidade para deixar o cÃ³digo com Ã³tima aparÃªncia. Mas vamos ao que realmente interessa. Considere o seguinte exemplo:```Ruby# Primeira versÃ£orequire 'time'class Pedidoattr_reader :id :item_id :create_atattr_accessor :quantidade :preco_unitario:update_atdef initialize(params)@id = params[:id].to_i@item_id = params[:item_id].to_i@quantidade = params[:quantidade].to_i@preco_unitario = BigDecimal(params[:preco_unitario])@create_at = Time.parse(params[:create_at].to_s)@update_at = Time.parse(params[:update_at].to_s)enddef preco_unitario_para_realpreco_unitario.to_fendend```Mesmo programadores novos saberÃ£o o que estÃ¡ errado aqui. Quase dÃ³i ao olhar. Mas esse costuma ser o primeiro passo. Aprender como recuar blocos corretamente Ã© a chave para criar um cÃ³digo legÃ­vel e bonito. Vamos identar adequadamente cada linha. Vale constar que a convenÃ§Ã£o Ruby preconiza a utilizaÃ§Ã£o de 2 espaÃ§os para cada [1;35m\"[0m[31mninho[1;35m\"[0m[31m de cÃ³digo. Sendo assim:```Ruby# Segunda VersÃ£orequire 'time'class Pedido  attr_reader :id :item_id :create_at  attr_accessor :quantidade :preco_unitario:update_at  def initialize(params)    @id = params[:id].to_i    @item_id = params[:item_id].to_i    @quantidade = params[:quantidade].to_i    @preco_unitario = BigDecimal(params[:preco_unitario])    @create_at = Time.parse(params[:create_at].to_s)    @update_at = Time.parse(params[:update_at].to_s)  end  def preco_unitario_para_real    preco_unitario.to_f  endend```Muito melhor! Agora graÃ§as ao recuo ou identaÃ§Ã£o podemos ver o que pertence a o que sendo possÃ­vel identificar de maneira intuitiva o escopo de cada linha. Mas nÃ£o para por aqui! Acredito que hÃ¡ uma maneira mais bonita e organizada de exibir nosso attr_reader e attr_accessor.```Ruby# Terceira VersÃ£oclass Pedido  attr_reader   :id                :item_id                :create_at  attr_accessor :quantidade                :preco_unitario                :update_at```Quebrar cada declaraÃ§Ã£o de atributo em um linha alinhando-os uns com os outros deixa a leitura do cÃ³digo muito mais suave. Agora temos [1;35m\"[0m[31macessadores[1;35m\"[0m[31m de atributos bem recuados e com quebra de linha. Diga-me: Ficou ou nÃ£o mais fÃ¡cil dizer quais atributos sÃ£o apenas legÃ­veis (attr_reader) e quais tÃªm acesso total Ã  leitura e gravaÃ§Ã£o (attr_accessor)?Mas quanto ao mÃ©todo de inicializaÃ§Ã£o!? Sim ele estÃ¡  legÃ­vel. No entanto com tantas linhas penso que podemos simplificar a leitura. Com base nos alinhamentos feitos acima o que vocÃª Ã© capaz de sugerir? O que acha da seguinte revisÃ£o:```Ruby  def initialize(params)    @id             = params[:id].to_i    @item_id        = params[:item_id].to_i    @quantidade     = params[:quantidade].to_i    @preco_unitario = BigDecimal(params[:preco_unitario])    @create_at      = Time.parse(params[:create_at].to_s)    @update_at      = Time.parse(params[:update_at].to_s)  end```Para mim o alinhamento de todos esses operadores de atribuiÃ§Ã£o na mesma coluna cria um bloco de cÃ³digo realmente agradÃ¡vel consistente e legÃ­vel. Ã‰ fÃ¡cil dizer o que estÃ¡ acontecendo ainda mais rÃ¡pido do que antes quando apenas o recuao estava aplicado. Simplesmente alinhamos cada operador de atribuiÃ§Ã£o na coluna com a variÃ¡vel de instÃ¢ncia mais longa.Vamos dar uma olhada em toda a classe Pedido com novo visual:```Ruby# Quarta VersÃ£oclass Pedido  attr_reader   :id                :item_id                :create_at  attr_accessor :quantidade                :preco_unitario                :update_at  def initialize(params)    @id             = params[:id].to_i    @item_id        = params[:item_id].to_i    @quantidade     = params[:quantidade].to_i    @preco_unitario = BigDecimal(params[:preco_unitario])    @create_at      = Time.parse(params[:create_at].to_s)    @update_at      = Time.parse(params[:update_at].to_s)  end  def preco_unitario_para_real    preco_unitario.to_f  endend```Agora temos uma classe mais fÃ¡cil de ler sendo possÃ­vel entender com apenas uma rÃ¡pida olhada. O escopo Ã© facilmente identificÃ¡vel as atribuiÃ§Ãµes em nosso mÃ©todo de inicializaÃ§Ã£o sÃ£o fÃ¡ceis de escolher e nossos acessadores de atributos sÃ£o muito mais fÃ¡ceis de digerir.NÃ£o para por ai! Tenho mais oportunidades de melhoria para mostrar. EspaÃ§amento e alinhamento tambÃ©m podem ser utilizados para instanciar objetos com vÃ¡rios atributos. Olhe o antes e o depois:```Ruby# AntesUsuario.create(nome_completo: 'JoÃ£o Paulo Santos' userario: 'admin' senha: '123456' confirmacao_senha: '123456' email: 'joaopaulosilva123456@codei.com.br' data_nascimento: '01/01/2000')# DepoisUsuario.create(  nome_completo:     'JoÃ£o Paulo Santos'  userario:          'admin'  senha:             '123456'  confirmacao_senha: '123456'  email:             'joaopaulosilva123456@codei.com.br'  data_nascimento:   '01/01/2000')```Mais uma vez encontramos os mesmos problemas. Antes nÃ£o conseguÃ­amos nem ver o cÃ³digo inteiro. Trabalhar desta maneira Ã© muito ruim. Perdemos muito tempo percorrendo a Ã¡rea de visualizaÃ§Ã£o para conferir todos os atributos do novo usuÃ¡rio. ApÃ³s a revisÃ£o temos algo muito mais amigÃ¡vel.Por Ãºltimo considere o seguinte:```Ruby# Antesanimais = %w[cachorro vaca gato elefante galinha capivara cobra passaro]animais.map do |animal|  animal.capitalizeend```Aqui estamos iterando sobre a array animais e a cada elemento aplicando o mÃ©todo de capitalizaÃ§Ã£o. Ã“timo! Mas como tornÃ¡-lo mais simples? Acompanhe:```Ruby# Depoisanimais = %w[cachorro vaca gato elefante galinha capivara cobra passaro]animais.map(&:capitalize)```Chamar o mÃ©todo de capitalizaÃ§Ã£o desta maneira reduz o trabalho. Podemos dizer simplesmente [1;35m\"[0m[31mdÃª-me os animais com a primeira letra maiÃºscula[1;35m\"[0m[31m. Poderoso e flexÃ­vel nÃ£o? O melhor Ã© que funciona em muitas muitas outras situaÃ§Ãµes com todos os tipos de iteradores e enumerÃ¡veis.Done!Para finalizar como dito inicialmente esse tÃ³pico Ã© geralmente trivial mas um pouco de cuidado com o uso de espaÃ§os e recuo podem deixar seu trabalho em alto nÃ­vel. Tenha certeza que estas poucas dicas facilitarÃ£o trabalho em equipe e a manutenÃ§Ã£o do cÃ³digo. VocÃª dificilmente trabalharÃ¡ sozinho sendo a facilidade de leitura do que vocÃª faz por colegas fundamental para a escalabilidade de seus projetos no longo prazo.Um forte abraÃ§o e tudo de bom![1;31m"[0m[31m[0m,
 author: [31m[1;31m"[0m[31mGabriel Braico Dornas[1;31m"[0m[31m[0m,
 reading_time: [31m[1;31m"[0m[31m05 minutos[1;31m"[0m[31m[0m,
 github_link: [31m[1;31m"[0m[31mhttps://github.com/gabrielbdornas/codei-blog-posts-api/blob/master/db/posts_sources/20201026-deixe_seu_codigo_ruby_mais_estiloso.md[1;31m"[0m[31m[0m,
 md_editing_date: [1;34;4mTue[0m, [1;34m27[0m [1;34;4mOct[0m [1;34m2020[0m [1;34m14[0m:[1;34m48[0m:[1;34m30[0m [1;34;4mUTC[0m [1;34m+00[0m:[1;34m00[0m,
 created_at: [1;34;4mTue[0m, [1;34m27[0m [1;34;4mOct[0m [1;34m2020[0m [1;34m15[0m:[1;34m01[0m:[1;34m21[0m [1;34;4mUTC[0m [1;34m+00[0m:[1;34m00[0m,
 updated_at: [1;34;4mTue[0m, [1;34m27[0m [1;34;4mOct[0m [1;34m2020[0m [1;34m15[0m:[1;34m01[0m:[1;34m21[0m [1;34;4mUTC[0m [1;34m+00[0m:[1;34m00[0m[32m>[0m
